// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "prize.pb.h"
// @@protoc_insertion_point(includes)

namespace app {
namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class HeroTaskProto;
class TaskDataProto;
class TaskCompleteDialogProto;
class TaskProto;
class ChapterTaskProto;
class ChanceTaskProto;
class DailyTaskProto;
class NewYearDailyTaskProto;
class GuildTaskProto;
class GuildPlantTaskDataProto;
class TaskTargetProto;

enum TaskRelatedFunction {
  FUNC_SPELL = 1,
  FUNC_JUMP = 2,
  FUNC_FRIEND = 3,
  FUNC_DEPOT_SHOP = 4,
  FUNC_STORAGE = 5,
  FUNC_YUANBAO_SHOP = 6,
  FUNC_CHAPTER_DUNGEON = 7,
  FUNC_DAZUO = 8,
  FUNC_TEAM = 9,
  FUNC_DIVINE = 10,
  FUNC_MICRO_CLIENT = 11,
  FUNC_CHALLENGE_DUNGEON = 12,
  FUNC_BUY_MOUNT = 13,
  FUNC_RANKER = 14,
  FUNC_AUCTION = 15,
  FUNC_SIGN = 16,
  FUNC_ONLINE_PRIZE = 17,
  FUNC_GUILD = 18,
  FUNC_WORLD_BOSS = 19,
  FUNC_FIGHTING = 20,
  FUNC_CHAPTER_TASK = 21,
  FUNC_KONGCI_DUNGEON = 22,
  FUNC_SUPER_WEAPON = 23,
  FUNC_SHIELD_HERO = 24,
  FUNC_EQUIPMENT_REFINED = 25,
  FUNC_EQUIPMENT_QUALITY_UP = 26,
  FUNC_EQUIPMENT_LEVEL_UP = 27,
  FUNC_AUTO_COMBAT = 28,
  FUNC_BOW = 29,
  FUNC_GEM = 30,
  FUNC_PHOENIX = 31,
  FUNC_TIAN_JIE = 32,
  FUNC_TIAN_ZUI = 33,
  FUNC_SINGLE_FIGHT = 34,
  FUNC_MELTING = 35,
  FUNC_SOU_SHEN = 36,
  FUNC_GROUP_DUNGEON = 37,
  FUNC_STRONG = 38,
  FUNC_ACTIVITY = 39,
  FUNC_SERVER_ARENA = 40,
  FUNC_MAGIC_WEAPON = 41,
  FUNC_SHOU_CANG = 42,
  FUNC_SUPER_ARM = 43,
  FUNC_MELTING_GAOJI = 44,
  FUNC_DOTA = 45,
  FUNC_DEMON = 46,
  FUNC_CLOAK = 47,
  FUNC_YITIANSHENJUE = 48,
  FUNC_MOSHI = 49,
  FUNC_HE_CHENG = 50,
  FUNC_MARRIAGE = 51,
  FUNC_QIAN_QIU_DA_JIE = 52,
  FUNC_JING_JIE = 53,
  FUNC_TIAN_MEN = 54,
  FUNC_XIN_MO = 55,
  FUNC_CHI_HUO_SHEN_GONG = 56,
  FUNC_HTZ = 57,
  FUNC_ARENA_FIGHTING_TEAM = 58,
  FUNC_SUPER_WEAPON_GEM = 59,
  FUNC_MO_BING = 60,
  FUNC_WASH_XUNZHAN = 61,
  FUNC_LONG_XIAN = 62,
  FUNC_ZHAN_CHANG = 63,
  FUNC_TIAN_XIE = 64,
  FUNC_WU_DAO = 65,
  FUNC_TONG_TIN_TA = 66,
  FUNC_SHIELD = 67,
  FUNC_TONG_TIAN_BAO_JIAN = 68,
  FUNC_HAIDI = 69,
  FUNC_LING_YU = 70,
  FUNC_SHOP = 71,
  FUNC_FENG_YUN_DAO = 72,
  FUNC_BOW_TONG_LING = 74,
  FUNC_INLAY_BAO_SHI = 75,
  FUNC_MO_FANG = 76
};
bool TaskRelatedFunction_IsValid(int value);
const TaskRelatedFunction TaskRelatedFunction_MIN = FUNC_SPELL;
const TaskRelatedFunction TaskRelatedFunction_MAX = FUNC_MO_FANG;
const int TaskRelatedFunction_ARRAYSIZE = TaskRelatedFunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskRelatedFunction_descriptor();
inline const ::std::string& TaskRelatedFunction_Name(TaskRelatedFunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskRelatedFunction_descriptor(), value);
}
inline bool TaskRelatedFunction_Parse(
    const ::std::string& name, TaskRelatedFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskRelatedFunction>(
    TaskRelatedFunction_descriptor(), name, value);
}
enum CommonTaskType {
  TASK_TYPE_KILL_BOSS = 1,
  TASK_TYPE_FINISH_GUILD_TASK = 2,
  TASK_TYPE_FINISH_DAILY_TASK = 3,
  TASK_TYPE_FINISH_CHANCE_TASK = 4,
  TASK_TYPE_FINISH_BIAO = 5,
  TASK_TYPE_ENTER_COUPLE_DUNGEON = 6,
  TASK_TYPE_UPGRADE_PASSIVE_SPELL = 7,
  TASK_TYPE_UPGRADE_GUILD_SPELL = 8,
  TASK_TYPE_FINISH_SOU_SHEN = 9,
  TASK_TYPE_FINISH_STORY_DUNGEON = 10,
  TASK_TYPE_FINISH_CHALLENGE_DUNGEON = 11,
  TASK_TYPE_FINISH_TONG_TIAN_TA = 12,
  TASK_TYPE_FINISH_XIN_MO = 13,
  TASK_TYPE_RECHARGE_ONCE = 14,
  TASK_TYPE_TIAN_MING = 15,
  TASK_TYPE_SHEN_BING_WASH = 16,
  TASK_TYPE_PHOENIX_REFINE = 17,
  TASK_TYPE_MOUNT = 18,
  TASK_TYPE_TIAN_JIE = 19,
  TASK_TYPE_TIAN_ZUI = 20,
  TASK_TYPE_ZHAN_JIA = 21,
  TASK_TYPE_SUPER_ARM = 22,
  TASK_TYPE_DEMON = 23,
  TASK_TYPE_CLOAK = 24,
  TASK_TYPE_MOSHI_0 = 25,
  TASK_TYPE_MOSHI_1 = 26,
  TASK_TYPE_MOSHI_2 = 27,
  TASK_TYPE_MOSHI_3 = 28,
  TASK_TYPE_QIAN_QIU_DA_JIE_0 = 29,
  TASK_TYPE_QIAN_QIU_DA_JIE_1 = 30,
  TASK_TYPE_CHI_HUO_SHEN_GONG = 31,
  TASK_TYPE_TIAN_XIE = 32,
  TASK_TYPE_WU_DAO = 33,
  TASK_TYPE_SHIELD_1 = 34,
  TASK_TYPE_SHIELD_2 = 35,
  TASK_TYPE_SHIELD_3 = 36,
  TASK_TYPE_SHIELD_4 = 37,
  TASK_TYPE_SHIELD_5 = 38,
  TASK_TYPE_SHIELD_6 = 39,
  TASK_TYPE_SHIELD_7 = 40,
  TASK_TYPE_SHIELD_8 = 41,
  TASK_TYPE_SHIELD_9 = 42,
  TASK_TYPE_SHIELD_10 = 43,
  TASK_TYPE_HERO_LEVEL = 44,
  TASK_TYPE_SHEN_BING = 45,
  TASK_TYPE_MO_BING = 46,
  TASK_TYPE_TOTAL_MOSHI_JIE_SHU = 47,
  TASK_TYPE_TOTAL_QIAN_QIU_DA_JIE_JIE_SHU = 48
};
bool CommonTaskType_IsValid(int value);
const CommonTaskType CommonTaskType_MIN = TASK_TYPE_KILL_BOSS;
const CommonTaskType CommonTaskType_MAX = TASK_TYPE_TOTAL_QIAN_QIU_DA_JIE_JIE_SHU;
const int CommonTaskType_ARRAYSIZE = CommonTaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonTaskType_descriptor();
inline const ::std::string& CommonTaskType_Name(CommonTaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonTaskType_descriptor(), value);
}
inline bool CommonTaskType_Parse(
    const ::std::string& name, CommonTaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonTaskType>(
    CommonTaskType_descriptor(), name, value);
}
enum ClientFunction {
  FUNC_UNKOWN = 1
};
bool ClientFunction_IsValid(int value);
const ClientFunction ClientFunction_MIN = FUNC_UNKOWN;
const ClientFunction ClientFunction_MAX = FUNC_UNKOWN;
const int ClientFunction_ARRAYSIZE = ClientFunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientFunction_descriptor();
inline const ::std::string& ClientFunction_Name(ClientFunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientFunction_descriptor(), value);
}
inline bool ClientFunction_Parse(
    const ::std::string& name, ClientFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientFunction>(
    ClientFunction_descriptor(), name, value);
}
// ===================================================================

class HeroTaskProto : public ::google::protobuf::Message {
 public:
  HeroTaskProto();
  virtual ~HeroTaskProto();

  HeroTaskProto(const HeroTaskProto& from);

  inline HeroTaskProto& operator=(const HeroTaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeroTaskProto& default_instance();

  void Swap(HeroTaskProto* other);

  // implements Message ----------------------------------------------

  HeroTaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeroTaskProto& from);
  void MergeFrom(const HeroTaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.message.ChapterTaskProto doing_chapter_task = 1;
  inline bool has_doing_chapter_task() const;
  inline void clear_doing_chapter_task();
  static const int kDoingChapterTaskFieldNumber = 1;
  inline const ::app::message::ChapterTaskProto& doing_chapter_task() const;
  inline ::app::message::ChapterTaskProto* mutable_doing_chapter_task();
  inline ::app::message::ChapterTaskProto* release_doing_chapter_task();
  inline void set_allocated_doing_chapter_task(::app::message::ChapterTaskProto* doing_chapter_task);

  // optional int32 chance_task_swallowed_count = 11;
  inline bool has_chance_task_swallowed_count() const;
  inline void clear_chance_task_swallowed_count();
  static const int kChanceTaskSwallowedCountFieldNumber = 11;
  inline ::google::protobuf::int32 chance_task_swallowed_count() const;
  inline void set_chance_task_swallowed_count(::google::protobuf::int32 value);

  // optional int32 chance_task_accepted_count = 12;
  inline bool has_chance_task_accepted_count() const;
  inline void clear_chance_task_accepted_count();
  static const int kChanceTaskAcceptedCountFieldNumber = 12;
  inline ::google::protobuf::int32 chance_task_accepted_count() const;
  inline void set_chance_task_accepted_count(::google::protobuf::int32 value);

  // repeated int32 chance_task_auto_complete_count = 13;
  inline int chance_task_auto_complete_count_size() const;
  inline void clear_chance_task_auto_complete_count();
  static const int kChanceTaskAutoCompleteCountFieldNumber = 13;
  inline ::google::protobuf::int32 chance_task_auto_complete_count(int index) const;
  inline void set_chance_task_auto_complete_count(int index, ::google::protobuf::int32 value);
  inline void add_chance_task_auto_complete_count(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      chance_task_auto_complete_count() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_chance_task_auto_complete_count();

  // repeated .app.message.ChanceTaskProto chance_task = 14;
  inline int chance_task_size() const;
  inline void clear_chance_task();
  static const int kChanceTaskFieldNumber = 14;
  inline const ::app::message::ChanceTaskProto& chance_task(int index) const;
  inline ::app::message::ChanceTaskProto* mutable_chance_task(int index);
  inline ::app::message::ChanceTaskProto* add_chance_task();
  inline const ::google::protobuf::RepeatedPtrField< ::app::message::ChanceTaskProto >&
      chance_task() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::message::ChanceTaskProto >*
      mutable_chance_task();

  // optional .app.message.DailyTaskProto doing_daily_task = 21;
  inline bool has_doing_daily_task() const;
  inline void clear_doing_daily_task();
  static const int kDoingDailyTaskFieldNumber = 21;
  inline const ::app::message::DailyTaskProto& doing_daily_task() const;
  inline ::app::message::DailyTaskProto* mutable_doing_daily_task();
  inline ::app::message::DailyTaskProto* release_doing_daily_task();
  inline void set_allocated_doing_daily_task(::app::message::DailyTaskProto* doing_daily_task);

  // optional .app.message.NewYearDailyTaskProto doing_new_year_daily_task = 22;
  inline bool has_doing_new_year_daily_task() const;
  inline void clear_doing_new_year_daily_task();
  static const int kDoingNewYearDailyTaskFieldNumber = 22;
  inline const ::app::message::NewYearDailyTaskProto& doing_new_year_daily_task() const;
  inline ::app::message::NewYearDailyTaskProto* mutable_doing_new_year_daily_task();
  inline ::app::message::NewYearDailyTaskProto* release_doing_new_year_daily_task();
  inline void set_allocated_doing_new_year_daily_task(::app::message::NewYearDailyTaskProto* doing_new_year_daily_task);

  // optional bool is_finished_all_new_year_daily_task = 23;
  inline bool has_is_finished_all_new_year_daily_task() const;
  inline void clear_is_finished_all_new_year_daily_task();
  static const int kIsFinishedAllNewYearDailyTaskFieldNumber = 23;
  inline bool is_finished_all_new_year_daily_task() const;
  inline void set_is_finished_all_new_year_daily_task(bool value);

  // repeated bytes task_goods_datas = 31;
  inline int task_goods_datas_size() const;
  inline void clear_task_goods_datas();
  static const int kTaskGoodsDatasFieldNumber = 31;
  inline const ::std::string& task_goods_datas(int index) const;
  inline ::std::string* mutable_task_goods_datas(int index);
  inline void set_task_goods_datas(int index, const ::std::string& value);
  inline void set_task_goods_datas(int index, const char* value);
  inline void set_task_goods_datas(int index, const void* value, size_t size);
  inline ::std::string* add_task_goods_datas();
  inline void add_task_goods_datas(const ::std::string& value);
  inline void add_task_goods_datas(const char* value);
  inline void add_task_goods_datas(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& task_goods_datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_task_goods_datas();

  // repeated bytes task_goods_list = 32;
  inline int task_goods_list_size() const;
  inline void clear_task_goods_list();
  static const int kTaskGoodsListFieldNumber = 32;
  inline const ::std::string& task_goods_list(int index) const;
  inline ::std::string* mutable_task_goods_list(int index);
  inline void set_task_goods_list(int index, const ::std::string& value);
  inline void set_task_goods_list(int index, const char* value);
  inline void set_task_goods_list(int index, const void* value, size_t size);
  inline ::std::string* add_task_goods_list();
  inline void add_task_goods_list(const ::std::string& value);
  inline void add_task_goods_list(const char* value);
  inline void add_task_goods_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& task_goods_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_task_goods_list();

  // optional .app.message.GuildTaskProto doing_guild_task = 41;
  inline bool has_doing_guild_task() const;
  inline void clear_doing_guild_task();
  static const int kDoingGuildTaskFieldNumber = 41;
  inline const ::app::message::GuildTaskProto& doing_guild_task() const;
  inline ::app::message::GuildTaskProto* mutable_doing_guild_task();
  inline ::app::message::GuildTaskProto* release_doing_guild_task();
  inline void set_allocated_doing_guild_task(::app::message::GuildTaskProto* doing_guild_task);

  // @@protoc_insertion_point(class_scope:app.message.HeroTaskProto)
 private:
  inline void set_has_doing_chapter_task();
  inline void clear_has_doing_chapter_task();
  inline void set_has_chance_task_swallowed_count();
  inline void clear_has_chance_task_swallowed_count();
  inline void set_has_chance_task_accepted_count();
  inline void clear_has_chance_task_accepted_count();
  inline void set_has_doing_daily_task();
  inline void clear_has_doing_daily_task();
  inline void set_has_doing_new_year_daily_task();
  inline void clear_has_doing_new_year_daily_task();
  inline void set_has_is_finished_all_new_year_daily_task();
  inline void clear_has_is_finished_all_new_year_daily_task();
  inline void set_has_doing_guild_task();
  inline void clear_has_doing_guild_task();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::message::ChapterTaskProto* doing_chapter_task_;
  ::google::protobuf::int32 chance_task_swallowed_count_;
  ::google::protobuf::int32 chance_task_accepted_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > chance_task_auto_complete_count_;
  ::google::protobuf::RepeatedPtrField< ::app::message::ChanceTaskProto > chance_task_;
  ::app::message::DailyTaskProto* doing_daily_task_;
  ::app::message::NewYearDailyTaskProto* doing_new_year_daily_task_;
  ::google::protobuf::RepeatedPtrField< ::std::string> task_goods_datas_;
  ::google::protobuf::RepeatedPtrField< ::std::string> task_goods_list_;
  ::app::message::GuildTaskProto* doing_guild_task_;
  bool is_finished_all_new_year_daily_task_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static HeroTaskProto* default_instance_;
};
// -------------------------------------------------------------------

class TaskDataProto : public ::google::protobuf::Message {
 public:
  TaskDataProto();
  virtual ~TaskDataProto();

  TaskDataProto(const TaskDataProto& from);

  inline TaskDataProto& operator=(const TaskDataProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskDataProto& default_instance();

  void Swap(TaskDataProto* other);

  // implements Message ----------------------------------------------

  TaskDataProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskDataProto& from);
  void MergeFrom(const TaskDataProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // repeated .app.message.TaskTargetProto target = 3;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::app::message::TaskTargetProto& target(int index) const;
  inline ::app::message::TaskTargetProto* mutable_target(int index);
  inline ::app::message::TaskTargetProto* add_target();
  inline const ::google::protobuf::RepeatedPtrField< ::app::message::TaskTargetProto >&
      target() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::message::TaskTargetProto >*
      mutable_target();

  // optional .app.message.PrizeProto prize = 4;
  inline bool has_prize() const;
  inline void clear_prize();
  static const int kPrizeFieldNumber = 4;
  inline const ::app::message::PrizeProto& prize() const;
  inline ::app::message::PrizeProto* mutable_prize();
  inline ::app::message::PrizeProto* release_prize();
  inline void set_allocated_prize(::app::message::PrizeProto* prize);

  // optional bytes accept_dialog = 5;
  inline bool has_accept_dialog() const;
  inline void clear_accept_dialog();
  static const int kAcceptDialogFieldNumber = 5;
  inline const ::std::string& accept_dialog() const;
  inline void set_accept_dialog(const ::std::string& value);
  inline void set_accept_dialog(const char* value);
  inline void set_accept_dialog(const void* value, size_t size);
  inline ::std::string* mutable_accept_dialog();
  inline ::std::string* release_accept_dialog();
  inline void set_allocated_accept_dialog(::std::string* accept_dialog);

  // optional .app.message.TaskCompleteDialogProto complete_dialog = 6;
  inline bool has_complete_dialog() const;
  inline void clear_complete_dialog();
  static const int kCompleteDialogFieldNumber = 6;
  inline const ::app::message::TaskCompleteDialogProto& complete_dialog() const;
  inline ::app::message::TaskCompleteDialogProto* mutable_complete_dialog();
  inline ::app::message::TaskCompleteDialogProto* release_complete_dialog();
  inline void set_allocated_complete_dialog(::app::message::TaskCompleteDialogProto* complete_dialog);

  // @@protoc_insertion_point(class_scope:app.message.TaskDataProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_prize();
  inline void clear_has_prize();
  inline void set_has_accept_dialog();
  inline void clear_has_accept_dialog();
  inline void set_has_complete_dialog();
  inline void clear_has_complete_dialog();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* desc_;
  ::google::protobuf::RepeatedPtrField< ::app::message::TaskTargetProto > target_;
  ::app::message::PrizeProto* prize_;
  ::std::string* accept_dialog_;
  ::app::message::TaskCompleteDialogProto* complete_dialog_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskDataProto* default_instance_;
};
// -------------------------------------------------------------------

class TaskCompleteDialogProto : public ::google::protobuf::Message {
 public:
  TaskCompleteDialogProto();
  virtual ~TaskCompleteDialogProto();

  TaskCompleteDialogProto(const TaskCompleteDialogProto& from);

  inline TaskCompleteDialogProto& operator=(const TaskCompleteDialogProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskCompleteDialogProto& default_instance();

  void Swap(TaskCompleteDialogProto* other);

  // implements Message ----------------------------------------------

  TaskCompleteDialogProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskCompleteDialogProto& from);
  void MergeFrom(const TaskCompleteDialogProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string res = 2;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 2;
  inline const ::std::string& res() const;
  inline void set_res(const ::std::string& value);
  inline void set_res(const char* value);
  inline void set_res(const char* value, size_t size);
  inline ::std::string* mutable_res();
  inline ::std::string* release_res();
  inline void set_allocated_res(::std::string* res);

  // optional bytes dialog = 3;
  inline bool has_dialog() const;
  inline void clear_dialog();
  static const int kDialogFieldNumber = 3;
  inline const ::std::string& dialog() const;
  inline void set_dialog(const ::std::string& value);
  inline void set_dialog(const char* value);
  inline void set_dialog(const void* value, size_t size);
  inline ::std::string* mutable_dialog();
  inline ::std::string* release_dialog();
  inline void set_allocated_dialog(::std::string* dialog);

  // @@protoc_insertion_point(class_scope:app.message.TaskCompleteDialogProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_dialog();
  inline void clear_has_dialog();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* res_;
  ::std::string* dialog_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskCompleteDialogProto* default_instance_;
};
// -------------------------------------------------------------------

class TaskProto : public ::google::protobuf::Message {
 public:
  TaskProto();
  virtual ~TaskProto();

  TaskProto(const TaskProto& from);

  inline TaskProto& operator=(const TaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskProto& default_instance();

  void Swap(TaskProto* other);

  // implements Message ----------------------------------------------

  TaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskProto& from);
  void MergeFrom(const TaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .app.message.TaskDataProto data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::app::message::TaskDataProto& data() const;
  inline ::app::message::TaskDataProto* mutable_data();
  inline ::app::message::TaskDataProto* release_data();
  inline void set_allocated_data(::app::message::TaskDataProto* data);

  // repeated int32 progress = 3;
  inline int progress_size() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 3;
  inline ::google::protobuf::int32 progress(int index) const;
  inline void set_progress(int index, ::google::protobuf::int32 value);
  inline void add_progress(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      progress() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_progress();

  // @@protoc_insertion_point(class_scope:app.message.TaskProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::message::TaskDataProto* data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > progress_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskProto* default_instance_;
};
// -------------------------------------------------------------------

class ChapterTaskProto : public ::google::protobuf::Message {
 public:
  ChapterTaskProto();
  virtual ~ChapterTaskProto();

  ChapterTaskProto(const ChapterTaskProto& from);

  inline ChapterTaskProto& operator=(const ChapterTaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChapterTaskProto& default_instance();

  void Swap(ChapterTaskProto* other);

  // implements Message ----------------------------------------------

  ChapterTaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChapterTaskProto& from);
  void MergeFrom(const ChapterTaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 chapter = 1;
  inline bool has_chapter() const;
  inline void clear_chapter();
  static const int kChapterFieldNumber = 1;
  inline ::google::protobuf::int32 chapter() const;
  inline void set_chapter(::google::protobuf::int32 value);

  // repeated bytes completed_task = 2;
  inline int completed_task_size() const;
  inline void clear_completed_task();
  static const int kCompletedTaskFieldNumber = 2;
  inline const ::std::string& completed_task(int index) const;
  inline ::std::string* mutable_completed_task(int index);
  inline void set_completed_task(int index, const ::std::string& value);
  inline void set_completed_task(int index, const char* value);
  inline void set_completed_task(int index, const void* value, size_t size);
  inline ::std::string* add_completed_task();
  inline void add_completed_task(const ::std::string& value);
  inline void add_completed_task(const char* value);
  inline void add_completed_task(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& completed_task() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_completed_task();

  // optional .app.message.TaskProto base_task = 3;
  inline bool has_base_task() const;
  inline void clear_base_task();
  static const int kBaseTaskFieldNumber = 3;
  inline const ::app::message::TaskProto& base_task() const;
  inline ::app::message::TaskProto* mutable_base_task();
  inline ::app::message::TaskProto* release_base_task();
  inline void set_allocated_base_task(::app::message::TaskProto* base_task);

  // @@protoc_insertion_point(class_scope:app.message.ChapterTaskProto)
 private:
  inline void set_has_chapter();
  inline void clear_has_chapter();
  inline void set_has_base_task();
  inline void clear_has_base_task();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> completed_task_;
  ::app::message::TaskProto* base_task_;
  ::google::protobuf::int32 chapter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static ChapterTaskProto* default_instance_;
};
// -------------------------------------------------------------------

class ChanceTaskProto : public ::google::protobuf::Message {
 public:
  ChanceTaskProto();
  virtual ~ChanceTaskProto();

  ChanceTaskProto(const ChanceTaskProto& from);

  inline ChanceTaskProto& operator=(const ChanceTaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChanceTaskProto& default_instance();

  void Swap(ChanceTaskProto* other);

  // implements Message ----------------------------------------------

  ChanceTaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChanceTaskProto& from);
  void MergeFrom(const ChanceTaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.message.TaskProto base_task = 1;
  inline bool has_base_task() const;
  inline void clear_base_task();
  static const int kBaseTaskFieldNumber = 1;
  inline const ::app::message::TaskProto& base_task() const;
  inline ::app::message::TaskProto* mutable_base_task();
  inline ::app::message::TaskProto* release_base_task();
  inline void set_allocated_base_task(::app::message::TaskProto* base_task);

  // optional int32 swallow_percent = 2;
  inline bool has_swallow_percent() const;
  inline void clear_swallow_percent();
  static const int kSwallowPercentFieldNumber = 2;
  inline ::google::protobuf::int32 swallow_percent() const;
  inline void set_swallow_percent(::google::protobuf::int32 value);

  // optional int32 quality = 3;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 3;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional string head_image = 4;
  inline bool has_head_image() const;
  inline void clear_head_image();
  static const int kHeadImageFieldNumber = 4;
  inline const ::std::string& head_image() const;
  inline void set_head_image(const ::std::string& value);
  inline void set_head_image(const char* value);
  inline void set_head_image(const char* value, size_t size);
  inline ::std::string* mutable_head_image();
  inline ::std::string* release_head_image();
  inline void set_allocated_head_image(::std::string* head_image);

  // @@protoc_insertion_point(class_scope:app.message.ChanceTaskProto)
 private:
  inline void set_has_base_task();
  inline void clear_has_base_task();
  inline void set_has_swallow_percent();
  inline void clear_has_swallow_percent();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_head_image();
  inline void clear_has_head_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::message::TaskProto* base_task_;
  ::google::protobuf::int32 swallow_percent_;
  ::google::protobuf::int32 quality_;
  ::std::string* head_image_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static ChanceTaskProto* default_instance_;
};
// -------------------------------------------------------------------

class DailyTaskProto : public ::google::protobuf::Message {
 public:
  DailyTaskProto();
  virtual ~DailyTaskProto();

  DailyTaskProto(const DailyTaskProto& from);

  inline DailyTaskProto& operator=(const DailyTaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyTaskProto& default_instance();

  void Swap(DailyTaskProto* other);

  // implements Message ----------------------------------------------

  DailyTaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailyTaskProto& from);
  void MergeFrom(const DailyTaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.message.TaskProto base_task = 1;
  inline bool has_base_task() const;
  inline void clear_base_task();
  static const int kBaseTaskFieldNumber = 1;
  inline const ::app::message::TaskProto& base_task() const;
  inline ::app::message::TaskProto* mutable_base_task();
  inline ::app::message::TaskProto* release_base_task();
  inline void set_allocated_base_task(::app::message::TaskProto* base_task);

  // optional int32 round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // optional int32 diffi_star = 3;
  inline bool has_diffi_star() const;
  inline void clear_diffi_star();
  static const int kDiffiStarFieldNumber = 3;
  inline ::google::protobuf::int32 diffi_star() const;
  inline void set_diffi_star(::google::protobuf::int32 value);

  // optional int32 prize_star = 4;
  inline bool has_prize_star() const;
  inline void clear_prize_star();
  static const int kPrizeStarFieldNumber = 4;
  inline ::google::protobuf::int32 prize_star() const;
  inline void set_prize_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:app.message.DailyTaskProto)
 private:
  inline void set_has_base_task();
  inline void clear_has_base_task();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_diffi_star();
  inline void clear_has_diffi_star();
  inline void set_has_prize_star();
  inline void clear_has_prize_star();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::message::TaskProto* base_task_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 diffi_star_;
  ::google::protobuf::int32 prize_star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static DailyTaskProto* default_instance_;
};
// -------------------------------------------------------------------

class NewYearDailyTaskProto : public ::google::protobuf::Message {
 public:
  NewYearDailyTaskProto();
  virtual ~NewYearDailyTaskProto();

  NewYearDailyTaskProto(const NewYearDailyTaskProto& from);

  inline NewYearDailyTaskProto& operator=(const NewYearDailyTaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewYearDailyTaskProto& default_instance();

  void Swap(NewYearDailyTaskProto* other);

  // implements Message ----------------------------------------------

  NewYearDailyTaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewYearDailyTaskProto& from);
  void MergeFrom(const NewYearDailyTaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.message.TaskProto base_task = 1;
  inline bool has_base_task() const;
  inline void clear_base_task();
  static const int kBaseTaskFieldNumber = 1;
  inline const ::app::message::TaskProto& base_task() const;
  inline ::app::message::TaskProto* mutable_base_task();
  inline ::app::message::TaskProto* release_base_task();
  inline void set_allocated_base_task(::app::message::TaskProto* base_task);

  // optional int32 round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:app.message.NewYearDailyTaskProto)
 private:
  inline void set_has_base_task();
  inline void clear_has_base_task();
  inline void set_has_round();
  inline void clear_has_round();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::message::TaskProto* base_task_;
  ::google::protobuf::int32 round_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static NewYearDailyTaskProto* default_instance_;
};
// -------------------------------------------------------------------

class GuildTaskProto : public ::google::protobuf::Message {
 public:
  GuildTaskProto();
  virtual ~GuildTaskProto();

  GuildTaskProto(const GuildTaskProto& from);

  inline GuildTaskProto& operator=(const GuildTaskProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildTaskProto& default_instance();

  void Swap(GuildTaskProto* other);

  // implements Message ----------------------------------------------

  GuildTaskProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuildTaskProto& from);
  void MergeFrom(const GuildTaskProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.message.TaskProto base_task = 1;
  inline bool has_base_task() const;
  inline void clear_base_task();
  static const int kBaseTaskFieldNumber = 1;
  inline const ::app::message::TaskProto& base_task() const;
  inline ::app::message::TaskProto* mutable_base_task();
  inline ::app::message::TaskProto* release_base_task();
  inline void set_allocated_base_task(::app::message::TaskProto* base_task);

  // optional int32 round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:app.message.GuildTaskProto)
 private:
  inline void set_has_base_task();
  inline void clear_has_base_task();
  inline void set_has_round();
  inline void clear_has_round();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::message::TaskProto* base_task_;
  ::google::protobuf::int32 round_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static GuildTaskProto* default_instance_;
};
// -------------------------------------------------------------------

class GuildPlantTaskDataProto : public ::google::protobuf::Message {
 public:
  GuildPlantTaskDataProto();
  virtual ~GuildPlantTaskDataProto();

  GuildPlantTaskDataProto(const GuildPlantTaskDataProto& from);

  inline GuildPlantTaskDataProto& operator=(const GuildPlantTaskDataProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildPlantTaskDataProto& default_instance();

  void Swap(GuildPlantTaskDataProto* other);

  // implements Message ----------------------------------------------

  GuildPlantTaskDataProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuildPlantTaskDataProto& from);
  void MergeFrom(const GuildPlantTaskDataProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 accept_npc_id = 1;
  inline bool has_accept_npc_id() const;
  inline void clear_accept_npc_id();
  static const int kAcceptNpcIdFieldNumber = 1;
  inline ::google::protobuf::int32 accept_npc_id() const;
  inline void set_accept_npc_id(::google::protobuf::int32 value);

  // optional int32 complete_npc_id = 2;
  inline bool has_complete_npc_id() const;
  inline void clear_complete_npc_id();
  static const int kCompleteNpcIdFieldNumber = 2;
  inline ::google::protobuf::int32 complete_npc_id() const;
  inline void set_complete_npc_id(::google::protobuf::int32 value);

  // optional int32 task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline ::google::protobuf::int32 task_id() const;
  inline void set_task_id(::google::protobuf::int32 value);

  // optional .app.message.TaskDataProto base_task = 4;
  inline bool has_base_task() const;
  inline void clear_base_task();
  static const int kBaseTaskFieldNumber = 4;
  inline const ::app::message::TaskDataProto& base_task() const;
  inline ::app::message::TaskDataProto* mutable_base_task();
  inline ::app::message::TaskDataProto* release_base_task();
  inline void set_allocated_base_task(::app::message::TaskDataProto* base_task);

  // optional int32 ripe_degree_prize = 5;
  inline bool has_ripe_degree_prize() const;
  inline void clear_ripe_degree_prize();
  static const int kRipeDegreePrizeFieldNumber = 5;
  inline ::google::protobuf::int32 ripe_degree_prize() const;
  inline void set_ripe_degree_prize(::google::protobuf::int32 value);

  // repeated int32 phase = 6;
  inline int phase_size() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 6;
  inline ::google::protobuf::int32 phase(int index) const;
  inline void set_phase(int index, ::google::protobuf::int32 value);
  inline void add_phase(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      phase() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_phase();

  // repeated int32 times_limit = 7;
  inline int times_limit_size() const;
  inline void clear_times_limit();
  static const int kTimesLimitFieldNumber = 7;
  inline ::google::protobuf::int32 times_limit(int index) const;
  inline void set_times_limit(int index, ::google::protobuf::int32 value);
  inline void add_times_limit(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      times_limit() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_times_limit();

  // @@protoc_insertion_point(class_scope:app.message.GuildPlantTaskDataProto)
 private:
  inline void set_has_accept_npc_id();
  inline void clear_has_accept_npc_id();
  inline void set_has_complete_npc_id();
  inline void clear_has_complete_npc_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_base_task();
  inline void clear_has_base_task();
  inline void set_has_ripe_degree_prize();
  inline void clear_has_ripe_degree_prize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 accept_npc_id_;
  ::google::protobuf::int32 complete_npc_id_;
  ::app::message::TaskDataProto* base_task_;
  ::google::protobuf::int32 task_id_;
  ::google::protobuf::int32 ripe_degree_prize_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > phase_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > times_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static GuildPlantTaskDataProto* default_instance_;
};
// -------------------------------------------------------------------

class TaskTargetProto : public ::google::protobuf::Message {
 public:
  TaskTargetProto();
  virtual ~TaskTargetProto();

  TaskTargetProto(const TaskTargetProto& from);

  inline TaskTargetProto& operator=(const TaskTargetProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskTargetProto& default_instance();

  void Swap(TaskTargetProto* other);

  // implements Message ----------------------------------------------

  TaskTargetProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskTargetProto& from);
  void MergeFrom(const TaskTargetProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 npc_id = 2;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 2;
  inline ::google::protobuf::int32 npc_id() const;
  inline void set_npc_id(::google::protobuf::int32 value);

  // optional bytes npc_dialog = 3;
  inline bool has_npc_dialog() const;
  inline void clear_npc_dialog();
  static const int kNpcDialogFieldNumber = 3;
  inline const ::std::string& npc_dialog() const;
  inline void set_npc_dialog(const ::std::string& value);
  inline void set_npc_dialog(const char* value);
  inline void set_npc_dialog(const void* value, size_t size);
  inline ::std::string* mutable_npc_dialog();
  inline ::std::string* release_npc_dialog();
  inline void set_allocated_npc_dialog(::std::string* npc_dialog);

  // optional int32 kill_monster_id = 11;
  inline bool has_kill_monster_id() const;
  inline void clear_kill_monster_id();
  static const int kKillMonsterIdFieldNumber = 11;
  inline ::google::protobuf::int32 kill_monster_id() const;
  inline void set_kill_monster_id(::google::protobuf::int32 value);

  // optional int32 kill_monster_count = 12;
  inline bool has_kill_monster_count() const;
  inline void clear_kill_monster_count();
  static const int kKillMonsterCountFieldNumber = 12;
  inline ::google::protobuf::int32 kill_monster_count() const;
  inline void set_kill_monster_count(::google::protobuf::int32 value);

  // optional int32 drop_goods_monster_id = 21;
  inline bool has_drop_goods_monster_id() const;
  inline void clear_drop_goods_monster_id();
  static const int kDropGoodsMonsterIdFieldNumber = 21;
  inline ::google::protobuf::int32 drop_goods_monster_id() const;
  inline void set_drop_goods_monster_id(::google::protobuf::int32 value);

  // optional int32 drop_goods_count = 22;
  inline bool has_drop_goods_count() const;
  inline void clear_drop_goods_count();
  static const int kDropGoodsCountFieldNumber = 22;
  inline ::google::protobuf::int32 drop_goods_count() const;
  inline void set_drop_goods_count(::google::protobuf::int32 value);

  // optional bytes drop_goods_data = 23 [deprecated = true];
  inline bool has_drop_goods_data() const PROTOBUF_DEPRECATED;
  inline void clear_drop_goods_data() PROTOBUF_DEPRECATED;
  static const int kDropGoodsDataFieldNumber = 23;
  inline const ::std::string& drop_goods_data() const PROTOBUF_DEPRECATED;
  inline void set_drop_goods_data(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_drop_goods_data(const char* value) PROTOBUF_DEPRECATED;
  inline void set_drop_goods_data(const void* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_drop_goods_data() PROTOBUF_DEPRECATED;
  inline ::std::string* release_drop_goods_data() PROTOBUF_DEPRECATED;
  inline void set_allocated_drop_goods_data(::std::string* drop_goods_data) PROTOBUF_DEPRECATED;

  // optional bytes drop_goods_name = 24;
  inline bool has_drop_goods_name() const;
  inline void clear_drop_goods_name();
  static const int kDropGoodsNameFieldNumber = 24;
  inline const ::std::string& drop_goods_name() const;
  inline void set_drop_goods_name(const ::std::string& value);
  inline void set_drop_goods_name(const char* value);
  inline void set_drop_goods_name(const void* value, size_t size);
  inline ::std::string* mutable_drop_goods_name();
  inline ::std::string* release_drop_goods_name();
  inline void set_allocated_drop_goods_name(::std::string* drop_goods_name);

  // optional int32 collect_goods_type = 31;
  inline bool has_collect_goods_type() const;
  inline void clear_collect_goods_type();
  static const int kCollectGoodsTypeFieldNumber = 31;
  inline ::google::protobuf::int32 collect_goods_type() const;
  inline void set_collect_goods_type(::google::protobuf::int32 value);

  // optional int32 collect_goods_count = 32;
  inline bool has_collect_goods_count() const;
  inline void clear_collect_goods_count();
  static const int kCollectGoodsCountFieldNumber = 32;
  inline ::google::protobuf::int32 collect_goods_count() const;
  inline void set_collect_goods_count(::google::protobuf::int32 value);

  // optional bytes collect_goods_data = 33 [deprecated = true];
  inline bool has_collect_goods_data() const PROTOBUF_DEPRECATED;
  inline void clear_collect_goods_data() PROTOBUF_DEPRECATED;
  static const int kCollectGoodsDataFieldNumber = 33;
  inline const ::std::string& collect_goods_data() const PROTOBUF_DEPRECATED;
  inline void set_collect_goods_data(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_collect_goods_data(const char* value) PROTOBUF_DEPRECATED;
  inline void set_collect_goods_data(const void* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_collect_goods_data() PROTOBUF_DEPRECATED;
  inline ::std::string* release_collect_goods_data() PROTOBUF_DEPRECATED;
  inline void set_allocated_collect_goods_data(::std::string* collect_goods_data) PROTOBUF_DEPRECATED;

  // optional int32 upgrade_level = 41;
  inline bool has_upgrade_level() const;
  inline void clear_upgrade_level();
  static const int kUpgradeLevelFieldNumber = 41;
  inline ::google::protobuf::int32 upgrade_level() const;
  inline void set_upgrade_level(::google::protobuf::int32 value);

  // optional int32 upgrade_recommend_monster = 42;
  inline bool has_upgrade_recommend_monster() const;
  inline void clear_upgrade_recommend_monster();
  static const int kUpgradeRecommendMonsterFieldNumber = 42;
  inline ::google::protobuf::int32 upgrade_recommend_monster() const;
  inline void set_upgrade_recommend_monster(::google::protobuf::int32 value);

  // optional bytes depot_goods_data = 51;
  inline bool has_depot_goods_data() const;
  inline void clear_depot_goods_data();
  static const int kDepotGoodsDataFieldNumber = 51;
  inline const ::std::string& depot_goods_data() const;
  inline void set_depot_goods_data(const ::std::string& value);
  inline void set_depot_goods_data(const char* value);
  inline void set_depot_goods_data(const void* value, size_t size);
  inline ::std::string* mutable_depot_goods_data();
  inline ::std::string* release_depot_goods_data();
  inline void set_allocated_depot_goods_data(::std::string* depot_goods_data);

  // optional int32 depot_goods_count = 52;
  inline bool has_depot_goods_count() const;
  inline void clear_depot_goods_count();
  static const int kDepotGoodsCountFieldNumber = 52;
  inline ::google::protobuf::int32 depot_goods_count() const;
  inline void set_depot_goods_count(::google::protobuf::int32 value);

  // optional int32 dungeon = 61;
  inline bool has_dungeon() const;
  inline void clear_dungeon();
  static const int kDungeonFieldNumber = 61;
  inline ::google::protobuf::int32 dungeon() const;
  inline void set_dungeon(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:app.message.TaskTargetProto)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_npc_id();
  inline void clear_has_npc_id();
  inline void set_has_npc_dialog();
  inline void clear_has_npc_dialog();
  inline void set_has_kill_monster_id();
  inline void clear_has_kill_monster_id();
  inline void set_has_kill_monster_count();
  inline void clear_has_kill_monster_count();
  inline void set_has_drop_goods_monster_id();
  inline void clear_has_drop_goods_monster_id();
  inline void set_has_drop_goods_count();
  inline void clear_has_drop_goods_count();
  inline void set_has_drop_goods_data();
  inline void clear_has_drop_goods_data();
  inline void set_has_drop_goods_name();
  inline void clear_has_drop_goods_name();
  inline void set_has_collect_goods_type();
  inline void clear_has_collect_goods_type();
  inline void set_has_collect_goods_count();
  inline void clear_has_collect_goods_count();
  inline void set_has_collect_goods_data();
  inline void clear_has_collect_goods_data();
  inline void set_has_upgrade_level();
  inline void clear_has_upgrade_level();
  inline void set_has_upgrade_recommend_monster();
  inline void clear_has_upgrade_recommend_monster();
  inline void set_has_depot_goods_data();
  inline void clear_has_depot_goods_data();
  inline void set_has_depot_goods_count();
  inline void clear_has_depot_goods_count();
  inline void set_has_dungeon();
  inline void clear_has_dungeon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 npc_id_;
  ::std::string* npc_dialog_;
  ::google::protobuf::int32 kill_monster_id_;
  ::google::protobuf::int32 kill_monster_count_;
  ::google::protobuf::int32 drop_goods_monster_id_;
  ::google::protobuf::int32 drop_goods_count_;
  ::std::string* drop_goods_data_;
  ::std::string* drop_goods_name_;
  ::google::protobuf::int32 collect_goods_type_;
  ::google::protobuf::int32 collect_goods_count_;
  ::std::string* collect_goods_data_;
  ::google::protobuf::int32 upgrade_level_;
  ::google::protobuf::int32 upgrade_recommend_monster_;
  ::std::string* depot_goods_data_;
  ::google::protobuf::int32 depot_goods_count_;
  ::google::protobuf::int32 dungeon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskTargetProto* default_instance_;
};
// ===================================================================


// ===================================================================

// HeroTaskProto

// optional .app.message.ChapterTaskProto doing_chapter_task = 1;
inline bool HeroTaskProto::has_doing_chapter_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeroTaskProto::set_has_doing_chapter_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeroTaskProto::clear_has_doing_chapter_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeroTaskProto::clear_doing_chapter_task() {
  if (doing_chapter_task_ != NULL) doing_chapter_task_->::app::message::ChapterTaskProto::Clear();
  clear_has_doing_chapter_task();
}
inline const ::app::message::ChapterTaskProto& HeroTaskProto::doing_chapter_task() const {
  return doing_chapter_task_ != NULL ? *doing_chapter_task_ : *default_instance_->doing_chapter_task_;
}
inline ::app::message::ChapterTaskProto* HeroTaskProto::mutable_doing_chapter_task() {
  set_has_doing_chapter_task();
  if (doing_chapter_task_ == NULL) doing_chapter_task_ = new ::app::message::ChapterTaskProto;
  return doing_chapter_task_;
}
inline ::app::message::ChapterTaskProto* HeroTaskProto::release_doing_chapter_task() {
  clear_has_doing_chapter_task();
  ::app::message::ChapterTaskProto* temp = doing_chapter_task_;
  doing_chapter_task_ = NULL;
  return temp;
}
inline void HeroTaskProto::set_allocated_doing_chapter_task(::app::message::ChapterTaskProto* doing_chapter_task) {
  delete doing_chapter_task_;
  doing_chapter_task_ = doing_chapter_task;
  if (doing_chapter_task) {
    set_has_doing_chapter_task();
  } else {
    clear_has_doing_chapter_task();
  }
}

// optional int32 chance_task_swallowed_count = 11;
inline bool HeroTaskProto::has_chance_task_swallowed_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeroTaskProto::set_has_chance_task_swallowed_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeroTaskProto::clear_has_chance_task_swallowed_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeroTaskProto::clear_chance_task_swallowed_count() {
  chance_task_swallowed_count_ = 0;
  clear_has_chance_task_swallowed_count();
}
inline ::google::protobuf::int32 HeroTaskProto::chance_task_swallowed_count() const {
  return chance_task_swallowed_count_;
}
inline void HeroTaskProto::set_chance_task_swallowed_count(::google::protobuf::int32 value) {
  set_has_chance_task_swallowed_count();
  chance_task_swallowed_count_ = value;
}

// optional int32 chance_task_accepted_count = 12;
inline bool HeroTaskProto::has_chance_task_accepted_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeroTaskProto::set_has_chance_task_accepted_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeroTaskProto::clear_has_chance_task_accepted_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeroTaskProto::clear_chance_task_accepted_count() {
  chance_task_accepted_count_ = 0;
  clear_has_chance_task_accepted_count();
}
inline ::google::protobuf::int32 HeroTaskProto::chance_task_accepted_count() const {
  return chance_task_accepted_count_;
}
inline void HeroTaskProto::set_chance_task_accepted_count(::google::protobuf::int32 value) {
  set_has_chance_task_accepted_count();
  chance_task_accepted_count_ = value;
}

// repeated int32 chance_task_auto_complete_count = 13;
inline int HeroTaskProto::chance_task_auto_complete_count_size() const {
  return chance_task_auto_complete_count_.size();
}
inline void HeroTaskProto::clear_chance_task_auto_complete_count() {
  chance_task_auto_complete_count_.Clear();
}
inline ::google::protobuf::int32 HeroTaskProto::chance_task_auto_complete_count(int index) const {
  return chance_task_auto_complete_count_.Get(index);
}
inline void HeroTaskProto::set_chance_task_auto_complete_count(int index, ::google::protobuf::int32 value) {
  chance_task_auto_complete_count_.Set(index, value);
}
inline void HeroTaskProto::add_chance_task_auto_complete_count(::google::protobuf::int32 value) {
  chance_task_auto_complete_count_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
HeroTaskProto::chance_task_auto_complete_count() const {
  return chance_task_auto_complete_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
HeroTaskProto::mutable_chance_task_auto_complete_count() {
  return &chance_task_auto_complete_count_;
}

// repeated .app.message.ChanceTaskProto chance_task = 14;
inline int HeroTaskProto::chance_task_size() const {
  return chance_task_.size();
}
inline void HeroTaskProto::clear_chance_task() {
  chance_task_.Clear();
}
inline const ::app::message::ChanceTaskProto& HeroTaskProto::chance_task(int index) const {
  return chance_task_.Get(index);
}
inline ::app::message::ChanceTaskProto* HeroTaskProto::mutable_chance_task(int index) {
  return chance_task_.Mutable(index);
}
inline ::app::message::ChanceTaskProto* HeroTaskProto::add_chance_task() {
  return chance_task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::message::ChanceTaskProto >&
HeroTaskProto::chance_task() const {
  return chance_task_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::message::ChanceTaskProto >*
HeroTaskProto::mutable_chance_task() {
  return &chance_task_;
}

// optional .app.message.DailyTaskProto doing_daily_task = 21;
inline bool HeroTaskProto::has_doing_daily_task() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeroTaskProto::set_has_doing_daily_task() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeroTaskProto::clear_has_doing_daily_task() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeroTaskProto::clear_doing_daily_task() {
  if (doing_daily_task_ != NULL) doing_daily_task_->::app::message::DailyTaskProto::Clear();
  clear_has_doing_daily_task();
}
inline const ::app::message::DailyTaskProto& HeroTaskProto::doing_daily_task() const {
  return doing_daily_task_ != NULL ? *doing_daily_task_ : *default_instance_->doing_daily_task_;
}
inline ::app::message::DailyTaskProto* HeroTaskProto::mutable_doing_daily_task() {
  set_has_doing_daily_task();
  if (doing_daily_task_ == NULL) doing_daily_task_ = new ::app::message::DailyTaskProto;
  return doing_daily_task_;
}
inline ::app::message::DailyTaskProto* HeroTaskProto::release_doing_daily_task() {
  clear_has_doing_daily_task();
  ::app::message::DailyTaskProto* temp = doing_daily_task_;
  doing_daily_task_ = NULL;
  return temp;
}
inline void HeroTaskProto::set_allocated_doing_daily_task(::app::message::DailyTaskProto* doing_daily_task) {
  delete doing_daily_task_;
  doing_daily_task_ = doing_daily_task;
  if (doing_daily_task) {
    set_has_doing_daily_task();
  } else {
    clear_has_doing_daily_task();
  }
}

// optional .app.message.NewYearDailyTaskProto doing_new_year_daily_task = 22;
inline bool HeroTaskProto::has_doing_new_year_daily_task() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeroTaskProto::set_has_doing_new_year_daily_task() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeroTaskProto::clear_has_doing_new_year_daily_task() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeroTaskProto::clear_doing_new_year_daily_task() {
  if (doing_new_year_daily_task_ != NULL) doing_new_year_daily_task_->::app::message::NewYearDailyTaskProto::Clear();
  clear_has_doing_new_year_daily_task();
}
inline const ::app::message::NewYearDailyTaskProto& HeroTaskProto::doing_new_year_daily_task() const {
  return doing_new_year_daily_task_ != NULL ? *doing_new_year_daily_task_ : *default_instance_->doing_new_year_daily_task_;
}
inline ::app::message::NewYearDailyTaskProto* HeroTaskProto::mutable_doing_new_year_daily_task() {
  set_has_doing_new_year_daily_task();
  if (doing_new_year_daily_task_ == NULL) doing_new_year_daily_task_ = new ::app::message::NewYearDailyTaskProto;
  return doing_new_year_daily_task_;
}
inline ::app::message::NewYearDailyTaskProto* HeroTaskProto::release_doing_new_year_daily_task() {
  clear_has_doing_new_year_daily_task();
  ::app::message::NewYearDailyTaskProto* temp = doing_new_year_daily_task_;
  doing_new_year_daily_task_ = NULL;
  return temp;
}
inline void HeroTaskProto::set_allocated_doing_new_year_daily_task(::app::message::NewYearDailyTaskProto* doing_new_year_daily_task) {
  delete doing_new_year_daily_task_;
  doing_new_year_daily_task_ = doing_new_year_daily_task;
  if (doing_new_year_daily_task) {
    set_has_doing_new_year_daily_task();
  } else {
    clear_has_doing_new_year_daily_task();
  }
}

// optional bool is_finished_all_new_year_daily_task = 23;
inline bool HeroTaskProto::has_is_finished_all_new_year_daily_task() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeroTaskProto::set_has_is_finished_all_new_year_daily_task() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeroTaskProto::clear_has_is_finished_all_new_year_daily_task() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeroTaskProto::clear_is_finished_all_new_year_daily_task() {
  is_finished_all_new_year_daily_task_ = false;
  clear_has_is_finished_all_new_year_daily_task();
}
inline bool HeroTaskProto::is_finished_all_new_year_daily_task() const {
  return is_finished_all_new_year_daily_task_;
}
inline void HeroTaskProto::set_is_finished_all_new_year_daily_task(bool value) {
  set_has_is_finished_all_new_year_daily_task();
  is_finished_all_new_year_daily_task_ = value;
}

// repeated bytes task_goods_datas = 31;
inline int HeroTaskProto::task_goods_datas_size() const {
  return task_goods_datas_.size();
}
inline void HeroTaskProto::clear_task_goods_datas() {
  task_goods_datas_.Clear();
}
inline const ::std::string& HeroTaskProto::task_goods_datas(int index) const {
  return task_goods_datas_.Get(index);
}
inline ::std::string* HeroTaskProto::mutable_task_goods_datas(int index) {
  return task_goods_datas_.Mutable(index);
}
inline void HeroTaskProto::set_task_goods_datas(int index, const ::std::string& value) {
  task_goods_datas_.Mutable(index)->assign(value);
}
inline void HeroTaskProto::set_task_goods_datas(int index, const char* value) {
  task_goods_datas_.Mutable(index)->assign(value);
}
inline void HeroTaskProto::set_task_goods_datas(int index, const void* value, size_t size) {
  task_goods_datas_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroTaskProto::add_task_goods_datas() {
  return task_goods_datas_.Add();
}
inline void HeroTaskProto::add_task_goods_datas(const ::std::string& value) {
  task_goods_datas_.Add()->assign(value);
}
inline void HeroTaskProto::add_task_goods_datas(const char* value) {
  task_goods_datas_.Add()->assign(value);
}
inline void HeroTaskProto::add_task_goods_datas(const void* value, size_t size) {
  task_goods_datas_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeroTaskProto::task_goods_datas() const {
  return task_goods_datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeroTaskProto::mutable_task_goods_datas() {
  return &task_goods_datas_;
}

// repeated bytes task_goods_list = 32;
inline int HeroTaskProto::task_goods_list_size() const {
  return task_goods_list_.size();
}
inline void HeroTaskProto::clear_task_goods_list() {
  task_goods_list_.Clear();
}
inline const ::std::string& HeroTaskProto::task_goods_list(int index) const {
  return task_goods_list_.Get(index);
}
inline ::std::string* HeroTaskProto::mutable_task_goods_list(int index) {
  return task_goods_list_.Mutable(index);
}
inline void HeroTaskProto::set_task_goods_list(int index, const ::std::string& value) {
  task_goods_list_.Mutable(index)->assign(value);
}
inline void HeroTaskProto::set_task_goods_list(int index, const char* value) {
  task_goods_list_.Mutable(index)->assign(value);
}
inline void HeroTaskProto::set_task_goods_list(int index, const void* value, size_t size) {
  task_goods_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroTaskProto::add_task_goods_list() {
  return task_goods_list_.Add();
}
inline void HeroTaskProto::add_task_goods_list(const ::std::string& value) {
  task_goods_list_.Add()->assign(value);
}
inline void HeroTaskProto::add_task_goods_list(const char* value) {
  task_goods_list_.Add()->assign(value);
}
inline void HeroTaskProto::add_task_goods_list(const void* value, size_t size) {
  task_goods_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeroTaskProto::task_goods_list() const {
  return task_goods_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeroTaskProto::mutable_task_goods_list() {
  return &task_goods_list_;
}

// optional .app.message.GuildTaskProto doing_guild_task = 41;
inline bool HeroTaskProto::has_doing_guild_task() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeroTaskProto::set_has_doing_guild_task() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeroTaskProto::clear_has_doing_guild_task() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeroTaskProto::clear_doing_guild_task() {
  if (doing_guild_task_ != NULL) doing_guild_task_->::app::message::GuildTaskProto::Clear();
  clear_has_doing_guild_task();
}
inline const ::app::message::GuildTaskProto& HeroTaskProto::doing_guild_task() const {
  return doing_guild_task_ != NULL ? *doing_guild_task_ : *default_instance_->doing_guild_task_;
}
inline ::app::message::GuildTaskProto* HeroTaskProto::mutable_doing_guild_task() {
  set_has_doing_guild_task();
  if (doing_guild_task_ == NULL) doing_guild_task_ = new ::app::message::GuildTaskProto;
  return doing_guild_task_;
}
inline ::app::message::GuildTaskProto* HeroTaskProto::release_doing_guild_task() {
  clear_has_doing_guild_task();
  ::app::message::GuildTaskProto* temp = doing_guild_task_;
  doing_guild_task_ = NULL;
  return temp;
}
inline void HeroTaskProto::set_allocated_doing_guild_task(::app::message::GuildTaskProto* doing_guild_task) {
  delete doing_guild_task_;
  doing_guild_task_ = doing_guild_task;
  if (doing_guild_task) {
    set_has_doing_guild_task();
  } else {
    clear_has_doing_guild_task();
  }
}

// -------------------------------------------------------------------

// TaskDataProto

// optional bytes name = 1;
inline bool TaskDataProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskDataProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskDataProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskDataProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskDataProto::name() const {
  return *name_;
}
inline void TaskDataProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskDataProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskDataProto::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskDataProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskDataProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskDataProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes desc = 2;
inline bool TaskDataProto::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskDataProto::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskDataProto::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskDataProto::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TaskDataProto::desc() const {
  return *desc_;
}
inline void TaskDataProto::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TaskDataProto::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TaskDataProto::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskDataProto::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* TaskDataProto::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskDataProto::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .app.message.TaskTargetProto target = 3;
inline int TaskDataProto::target_size() const {
  return target_.size();
}
inline void TaskDataProto::clear_target() {
  target_.Clear();
}
inline const ::app::message::TaskTargetProto& TaskDataProto::target(int index) const {
  return target_.Get(index);
}
inline ::app::message::TaskTargetProto* TaskDataProto::mutable_target(int index) {
  return target_.Mutable(index);
}
inline ::app::message::TaskTargetProto* TaskDataProto::add_target() {
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::message::TaskTargetProto >&
TaskDataProto::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::message::TaskTargetProto >*
TaskDataProto::mutable_target() {
  return &target_;
}

// optional .app.message.PrizeProto prize = 4;
inline bool TaskDataProto::has_prize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskDataProto::set_has_prize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskDataProto::clear_has_prize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskDataProto::clear_prize() {
  if (prize_ != NULL) prize_->::app::message::PrizeProto::Clear();
  clear_has_prize();
}
inline const ::app::message::PrizeProto& TaskDataProto::prize() const {
  return prize_ != NULL ? *prize_ : *default_instance_->prize_;
}
inline ::app::message::PrizeProto* TaskDataProto::mutable_prize() {
  set_has_prize();
  if (prize_ == NULL) prize_ = new ::app::message::PrizeProto;
  return prize_;
}
inline ::app::message::PrizeProto* TaskDataProto::release_prize() {
  clear_has_prize();
  ::app::message::PrizeProto* temp = prize_;
  prize_ = NULL;
  return temp;
}
inline void TaskDataProto::set_allocated_prize(::app::message::PrizeProto* prize) {
  delete prize_;
  prize_ = prize;
  if (prize) {
    set_has_prize();
  } else {
    clear_has_prize();
  }
}

// optional bytes accept_dialog = 5;
inline bool TaskDataProto::has_accept_dialog() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskDataProto::set_has_accept_dialog() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskDataProto::clear_has_accept_dialog() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskDataProto::clear_accept_dialog() {
  if (accept_dialog_ != &::google::protobuf::internal::kEmptyString) {
    accept_dialog_->clear();
  }
  clear_has_accept_dialog();
}
inline const ::std::string& TaskDataProto::accept_dialog() const {
  return *accept_dialog_;
}
inline void TaskDataProto::set_accept_dialog(const ::std::string& value) {
  set_has_accept_dialog();
  if (accept_dialog_ == &::google::protobuf::internal::kEmptyString) {
    accept_dialog_ = new ::std::string;
  }
  accept_dialog_->assign(value);
}
inline void TaskDataProto::set_accept_dialog(const char* value) {
  set_has_accept_dialog();
  if (accept_dialog_ == &::google::protobuf::internal::kEmptyString) {
    accept_dialog_ = new ::std::string;
  }
  accept_dialog_->assign(value);
}
inline void TaskDataProto::set_accept_dialog(const void* value, size_t size) {
  set_has_accept_dialog();
  if (accept_dialog_ == &::google::protobuf::internal::kEmptyString) {
    accept_dialog_ = new ::std::string;
  }
  accept_dialog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskDataProto::mutable_accept_dialog() {
  set_has_accept_dialog();
  if (accept_dialog_ == &::google::protobuf::internal::kEmptyString) {
    accept_dialog_ = new ::std::string;
  }
  return accept_dialog_;
}
inline ::std::string* TaskDataProto::release_accept_dialog() {
  clear_has_accept_dialog();
  if (accept_dialog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accept_dialog_;
    accept_dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskDataProto::set_allocated_accept_dialog(::std::string* accept_dialog) {
  if (accept_dialog_ != &::google::protobuf::internal::kEmptyString) {
    delete accept_dialog_;
  }
  if (accept_dialog) {
    set_has_accept_dialog();
    accept_dialog_ = accept_dialog;
  } else {
    clear_has_accept_dialog();
    accept_dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .app.message.TaskCompleteDialogProto complete_dialog = 6;
inline bool TaskDataProto::has_complete_dialog() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskDataProto::set_has_complete_dialog() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskDataProto::clear_has_complete_dialog() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskDataProto::clear_complete_dialog() {
  if (complete_dialog_ != NULL) complete_dialog_->::app::message::TaskCompleteDialogProto::Clear();
  clear_has_complete_dialog();
}
inline const ::app::message::TaskCompleteDialogProto& TaskDataProto::complete_dialog() const {
  return complete_dialog_ != NULL ? *complete_dialog_ : *default_instance_->complete_dialog_;
}
inline ::app::message::TaskCompleteDialogProto* TaskDataProto::mutable_complete_dialog() {
  set_has_complete_dialog();
  if (complete_dialog_ == NULL) complete_dialog_ = new ::app::message::TaskCompleteDialogProto;
  return complete_dialog_;
}
inline ::app::message::TaskCompleteDialogProto* TaskDataProto::release_complete_dialog() {
  clear_has_complete_dialog();
  ::app::message::TaskCompleteDialogProto* temp = complete_dialog_;
  complete_dialog_ = NULL;
  return temp;
}
inline void TaskDataProto::set_allocated_complete_dialog(::app::message::TaskCompleteDialogProto* complete_dialog) {
  delete complete_dialog_;
  complete_dialog_ = complete_dialog;
  if (complete_dialog) {
    set_has_complete_dialog();
  } else {
    clear_has_complete_dialog();
  }
}

// -------------------------------------------------------------------

// TaskCompleteDialogProto

// optional bytes name = 1;
inline bool TaskCompleteDialogProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskCompleteDialogProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskCompleteDialogProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskCompleteDialogProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskCompleteDialogProto::name() const {
  return *name_;
}
inline void TaskCompleteDialogProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskCompleteDialogProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskCompleteDialogProto::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskCompleteDialogProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskCompleteDialogProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskCompleteDialogProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string res = 2;
inline bool TaskCompleteDialogProto::has_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskCompleteDialogProto::set_has_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskCompleteDialogProto::clear_has_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskCompleteDialogProto::clear_res() {
  if (res_ != &::google::protobuf::internal::kEmptyString) {
    res_->clear();
  }
  clear_has_res();
}
inline const ::std::string& TaskCompleteDialogProto::res() const {
  return *res_;
}
inline void TaskCompleteDialogProto::set_res(const ::std::string& value) {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  res_->assign(value);
}
inline void TaskCompleteDialogProto::set_res(const char* value) {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  res_->assign(value);
}
inline void TaskCompleteDialogProto::set_res(const char* value, size_t size) {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  res_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskCompleteDialogProto::mutable_res() {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  return res_;
}
inline ::std::string* TaskCompleteDialogProto::release_res() {
  clear_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = res_;
    res_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskCompleteDialogProto::set_allocated_res(::std::string* res) {
  if (res_ != &::google::protobuf::internal::kEmptyString) {
    delete res_;
  }
  if (res) {
    set_has_res();
    res_ = res;
  } else {
    clear_has_res();
    res_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes dialog = 3;
inline bool TaskCompleteDialogProto::has_dialog() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskCompleteDialogProto::set_has_dialog() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskCompleteDialogProto::clear_has_dialog() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskCompleteDialogProto::clear_dialog() {
  if (dialog_ != &::google::protobuf::internal::kEmptyString) {
    dialog_->clear();
  }
  clear_has_dialog();
}
inline const ::std::string& TaskCompleteDialogProto::dialog() const {
  return *dialog_;
}
inline void TaskCompleteDialogProto::set_dialog(const ::std::string& value) {
  set_has_dialog();
  if (dialog_ == &::google::protobuf::internal::kEmptyString) {
    dialog_ = new ::std::string;
  }
  dialog_->assign(value);
}
inline void TaskCompleteDialogProto::set_dialog(const char* value) {
  set_has_dialog();
  if (dialog_ == &::google::protobuf::internal::kEmptyString) {
    dialog_ = new ::std::string;
  }
  dialog_->assign(value);
}
inline void TaskCompleteDialogProto::set_dialog(const void* value, size_t size) {
  set_has_dialog();
  if (dialog_ == &::google::protobuf::internal::kEmptyString) {
    dialog_ = new ::std::string;
  }
  dialog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskCompleteDialogProto::mutable_dialog() {
  set_has_dialog();
  if (dialog_ == &::google::protobuf::internal::kEmptyString) {
    dialog_ = new ::std::string;
  }
  return dialog_;
}
inline ::std::string* TaskCompleteDialogProto::release_dialog() {
  clear_has_dialog();
  if (dialog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dialog_;
    dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskCompleteDialogProto::set_allocated_dialog(::std::string* dialog) {
  if (dialog_ != &::google::protobuf::internal::kEmptyString) {
    delete dialog_;
  }
  if (dialog) {
    set_has_dialog();
    dialog_ = dialog;
  } else {
    clear_has_dialog();
    dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskProto

// optional int32 id = 1;
inline bool TaskProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskProto::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TaskProto::id() const {
  return id_;
}
inline void TaskProto::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .app.message.TaskDataProto data = 2;
inline bool TaskProto::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskProto::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskProto::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskProto::clear_data() {
  if (data_ != NULL) data_->::app::message::TaskDataProto::Clear();
  clear_has_data();
}
inline const ::app::message::TaskDataProto& TaskProto::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::app::message::TaskDataProto* TaskProto::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::app::message::TaskDataProto;
  return data_;
}
inline ::app::message::TaskDataProto* TaskProto::release_data() {
  clear_has_data();
  ::app::message::TaskDataProto* temp = data_;
  data_ = NULL;
  return temp;
}
inline void TaskProto::set_allocated_data(::app::message::TaskDataProto* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// repeated int32 progress = 3;
inline int TaskProto::progress_size() const {
  return progress_.size();
}
inline void TaskProto::clear_progress() {
  progress_.Clear();
}
inline ::google::protobuf::int32 TaskProto::progress(int index) const {
  return progress_.Get(index);
}
inline void TaskProto::set_progress(int index, ::google::protobuf::int32 value) {
  progress_.Set(index, value);
}
inline void TaskProto::add_progress(::google::protobuf::int32 value) {
  progress_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TaskProto::progress() const {
  return progress_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TaskProto::mutable_progress() {
  return &progress_;
}

// -------------------------------------------------------------------

// ChapterTaskProto

// optional int32 chapter = 1;
inline bool ChapterTaskProto::has_chapter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChapterTaskProto::set_has_chapter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChapterTaskProto::clear_has_chapter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChapterTaskProto::clear_chapter() {
  chapter_ = 0;
  clear_has_chapter();
}
inline ::google::protobuf::int32 ChapterTaskProto::chapter() const {
  return chapter_;
}
inline void ChapterTaskProto::set_chapter(::google::protobuf::int32 value) {
  set_has_chapter();
  chapter_ = value;
}

// repeated bytes completed_task = 2;
inline int ChapterTaskProto::completed_task_size() const {
  return completed_task_.size();
}
inline void ChapterTaskProto::clear_completed_task() {
  completed_task_.Clear();
}
inline const ::std::string& ChapterTaskProto::completed_task(int index) const {
  return completed_task_.Get(index);
}
inline ::std::string* ChapterTaskProto::mutable_completed_task(int index) {
  return completed_task_.Mutable(index);
}
inline void ChapterTaskProto::set_completed_task(int index, const ::std::string& value) {
  completed_task_.Mutable(index)->assign(value);
}
inline void ChapterTaskProto::set_completed_task(int index, const char* value) {
  completed_task_.Mutable(index)->assign(value);
}
inline void ChapterTaskProto::set_completed_task(int index, const void* value, size_t size) {
  completed_task_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChapterTaskProto::add_completed_task() {
  return completed_task_.Add();
}
inline void ChapterTaskProto::add_completed_task(const ::std::string& value) {
  completed_task_.Add()->assign(value);
}
inline void ChapterTaskProto::add_completed_task(const char* value) {
  completed_task_.Add()->assign(value);
}
inline void ChapterTaskProto::add_completed_task(const void* value, size_t size) {
  completed_task_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChapterTaskProto::completed_task() const {
  return completed_task_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChapterTaskProto::mutable_completed_task() {
  return &completed_task_;
}

// optional .app.message.TaskProto base_task = 3;
inline bool ChapterTaskProto::has_base_task() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChapterTaskProto::set_has_base_task() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChapterTaskProto::clear_has_base_task() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChapterTaskProto::clear_base_task() {
  if (base_task_ != NULL) base_task_->::app::message::TaskProto::Clear();
  clear_has_base_task();
}
inline const ::app::message::TaskProto& ChapterTaskProto::base_task() const {
  return base_task_ != NULL ? *base_task_ : *default_instance_->base_task_;
}
inline ::app::message::TaskProto* ChapterTaskProto::mutable_base_task() {
  set_has_base_task();
  if (base_task_ == NULL) base_task_ = new ::app::message::TaskProto;
  return base_task_;
}
inline ::app::message::TaskProto* ChapterTaskProto::release_base_task() {
  clear_has_base_task();
  ::app::message::TaskProto* temp = base_task_;
  base_task_ = NULL;
  return temp;
}
inline void ChapterTaskProto::set_allocated_base_task(::app::message::TaskProto* base_task) {
  delete base_task_;
  base_task_ = base_task;
  if (base_task) {
    set_has_base_task();
  } else {
    clear_has_base_task();
  }
}

// -------------------------------------------------------------------

// ChanceTaskProto

// optional .app.message.TaskProto base_task = 1;
inline bool ChanceTaskProto::has_base_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChanceTaskProto::set_has_base_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChanceTaskProto::clear_has_base_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChanceTaskProto::clear_base_task() {
  if (base_task_ != NULL) base_task_->::app::message::TaskProto::Clear();
  clear_has_base_task();
}
inline const ::app::message::TaskProto& ChanceTaskProto::base_task() const {
  return base_task_ != NULL ? *base_task_ : *default_instance_->base_task_;
}
inline ::app::message::TaskProto* ChanceTaskProto::mutable_base_task() {
  set_has_base_task();
  if (base_task_ == NULL) base_task_ = new ::app::message::TaskProto;
  return base_task_;
}
inline ::app::message::TaskProto* ChanceTaskProto::release_base_task() {
  clear_has_base_task();
  ::app::message::TaskProto* temp = base_task_;
  base_task_ = NULL;
  return temp;
}
inline void ChanceTaskProto::set_allocated_base_task(::app::message::TaskProto* base_task) {
  delete base_task_;
  base_task_ = base_task;
  if (base_task) {
    set_has_base_task();
  } else {
    clear_has_base_task();
  }
}

// optional int32 swallow_percent = 2;
inline bool ChanceTaskProto::has_swallow_percent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChanceTaskProto::set_has_swallow_percent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChanceTaskProto::clear_has_swallow_percent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChanceTaskProto::clear_swallow_percent() {
  swallow_percent_ = 0;
  clear_has_swallow_percent();
}
inline ::google::protobuf::int32 ChanceTaskProto::swallow_percent() const {
  return swallow_percent_;
}
inline void ChanceTaskProto::set_swallow_percent(::google::protobuf::int32 value) {
  set_has_swallow_percent();
  swallow_percent_ = value;
}

// optional int32 quality = 3;
inline bool ChanceTaskProto::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChanceTaskProto::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChanceTaskProto::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChanceTaskProto::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 ChanceTaskProto::quality() const {
  return quality_;
}
inline void ChanceTaskProto::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional string head_image = 4;
inline bool ChanceTaskProto::has_head_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChanceTaskProto::set_has_head_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChanceTaskProto::clear_has_head_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChanceTaskProto::clear_head_image() {
  if (head_image_ != &::google::protobuf::internal::kEmptyString) {
    head_image_->clear();
  }
  clear_has_head_image();
}
inline const ::std::string& ChanceTaskProto::head_image() const {
  return *head_image_;
}
inline void ChanceTaskProto::set_head_image(const ::std::string& value) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(value);
}
inline void ChanceTaskProto::set_head_image(const char* value) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(value);
}
inline void ChanceTaskProto::set_head_image(const char* value, size_t size) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChanceTaskProto::mutable_head_image() {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  return head_image_;
}
inline ::std::string* ChanceTaskProto::release_head_image() {
  clear_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_image_;
    head_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChanceTaskProto::set_allocated_head_image(::std::string* head_image) {
  if (head_image_ != &::google::protobuf::internal::kEmptyString) {
    delete head_image_;
  }
  if (head_image) {
    set_has_head_image();
    head_image_ = head_image;
  } else {
    clear_has_head_image();
    head_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DailyTaskProto

// optional .app.message.TaskProto base_task = 1;
inline bool DailyTaskProto::has_base_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyTaskProto::set_has_base_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyTaskProto::clear_has_base_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyTaskProto::clear_base_task() {
  if (base_task_ != NULL) base_task_->::app::message::TaskProto::Clear();
  clear_has_base_task();
}
inline const ::app::message::TaskProto& DailyTaskProto::base_task() const {
  return base_task_ != NULL ? *base_task_ : *default_instance_->base_task_;
}
inline ::app::message::TaskProto* DailyTaskProto::mutable_base_task() {
  set_has_base_task();
  if (base_task_ == NULL) base_task_ = new ::app::message::TaskProto;
  return base_task_;
}
inline ::app::message::TaskProto* DailyTaskProto::release_base_task() {
  clear_has_base_task();
  ::app::message::TaskProto* temp = base_task_;
  base_task_ = NULL;
  return temp;
}
inline void DailyTaskProto::set_allocated_base_task(::app::message::TaskProto* base_task) {
  delete base_task_;
  base_task_ = base_task;
  if (base_task) {
    set_has_base_task();
  } else {
    clear_has_base_task();
  }
}

// optional int32 round = 2;
inline bool DailyTaskProto::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyTaskProto::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyTaskProto::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyTaskProto::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 DailyTaskProto::round() const {
  return round_;
}
inline void DailyTaskProto::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// optional int32 diffi_star = 3;
inline bool DailyTaskProto::has_diffi_star() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyTaskProto::set_has_diffi_star() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyTaskProto::clear_has_diffi_star() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyTaskProto::clear_diffi_star() {
  diffi_star_ = 0;
  clear_has_diffi_star();
}
inline ::google::protobuf::int32 DailyTaskProto::diffi_star() const {
  return diffi_star_;
}
inline void DailyTaskProto::set_diffi_star(::google::protobuf::int32 value) {
  set_has_diffi_star();
  diffi_star_ = value;
}

// optional int32 prize_star = 4;
inline bool DailyTaskProto::has_prize_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyTaskProto::set_has_prize_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyTaskProto::clear_has_prize_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyTaskProto::clear_prize_star() {
  prize_star_ = 0;
  clear_has_prize_star();
}
inline ::google::protobuf::int32 DailyTaskProto::prize_star() const {
  return prize_star_;
}
inline void DailyTaskProto::set_prize_star(::google::protobuf::int32 value) {
  set_has_prize_star();
  prize_star_ = value;
}

// -------------------------------------------------------------------

// NewYearDailyTaskProto

// optional .app.message.TaskProto base_task = 1;
inline bool NewYearDailyTaskProto::has_base_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewYearDailyTaskProto::set_has_base_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewYearDailyTaskProto::clear_has_base_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewYearDailyTaskProto::clear_base_task() {
  if (base_task_ != NULL) base_task_->::app::message::TaskProto::Clear();
  clear_has_base_task();
}
inline const ::app::message::TaskProto& NewYearDailyTaskProto::base_task() const {
  return base_task_ != NULL ? *base_task_ : *default_instance_->base_task_;
}
inline ::app::message::TaskProto* NewYearDailyTaskProto::mutable_base_task() {
  set_has_base_task();
  if (base_task_ == NULL) base_task_ = new ::app::message::TaskProto;
  return base_task_;
}
inline ::app::message::TaskProto* NewYearDailyTaskProto::release_base_task() {
  clear_has_base_task();
  ::app::message::TaskProto* temp = base_task_;
  base_task_ = NULL;
  return temp;
}
inline void NewYearDailyTaskProto::set_allocated_base_task(::app::message::TaskProto* base_task) {
  delete base_task_;
  base_task_ = base_task;
  if (base_task) {
    set_has_base_task();
  } else {
    clear_has_base_task();
  }
}

// optional int32 round = 2;
inline bool NewYearDailyTaskProto::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewYearDailyTaskProto::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewYearDailyTaskProto::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewYearDailyTaskProto::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 NewYearDailyTaskProto::round() const {
  return round_;
}
inline void NewYearDailyTaskProto::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// -------------------------------------------------------------------

// GuildTaskProto

// optional .app.message.TaskProto base_task = 1;
inline bool GuildTaskProto::has_base_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildTaskProto::set_has_base_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildTaskProto::clear_has_base_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildTaskProto::clear_base_task() {
  if (base_task_ != NULL) base_task_->::app::message::TaskProto::Clear();
  clear_has_base_task();
}
inline const ::app::message::TaskProto& GuildTaskProto::base_task() const {
  return base_task_ != NULL ? *base_task_ : *default_instance_->base_task_;
}
inline ::app::message::TaskProto* GuildTaskProto::mutable_base_task() {
  set_has_base_task();
  if (base_task_ == NULL) base_task_ = new ::app::message::TaskProto;
  return base_task_;
}
inline ::app::message::TaskProto* GuildTaskProto::release_base_task() {
  clear_has_base_task();
  ::app::message::TaskProto* temp = base_task_;
  base_task_ = NULL;
  return temp;
}
inline void GuildTaskProto::set_allocated_base_task(::app::message::TaskProto* base_task) {
  delete base_task_;
  base_task_ = base_task;
  if (base_task) {
    set_has_base_task();
  } else {
    clear_has_base_task();
  }
}

// optional int32 round = 2;
inline bool GuildTaskProto::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildTaskProto::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildTaskProto::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildTaskProto::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 GuildTaskProto::round() const {
  return round_;
}
inline void GuildTaskProto::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// -------------------------------------------------------------------

// GuildPlantTaskDataProto

// optional int32 accept_npc_id = 1;
inline bool GuildPlantTaskDataProto::has_accept_npc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildPlantTaskDataProto::set_has_accept_npc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildPlantTaskDataProto::clear_has_accept_npc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildPlantTaskDataProto::clear_accept_npc_id() {
  accept_npc_id_ = 0;
  clear_has_accept_npc_id();
}
inline ::google::protobuf::int32 GuildPlantTaskDataProto::accept_npc_id() const {
  return accept_npc_id_;
}
inline void GuildPlantTaskDataProto::set_accept_npc_id(::google::protobuf::int32 value) {
  set_has_accept_npc_id();
  accept_npc_id_ = value;
}

// optional int32 complete_npc_id = 2;
inline bool GuildPlantTaskDataProto::has_complete_npc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildPlantTaskDataProto::set_has_complete_npc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildPlantTaskDataProto::clear_has_complete_npc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildPlantTaskDataProto::clear_complete_npc_id() {
  complete_npc_id_ = 0;
  clear_has_complete_npc_id();
}
inline ::google::protobuf::int32 GuildPlantTaskDataProto::complete_npc_id() const {
  return complete_npc_id_;
}
inline void GuildPlantTaskDataProto::set_complete_npc_id(::google::protobuf::int32 value) {
  set_has_complete_npc_id();
  complete_npc_id_ = value;
}

// optional int32 task_id = 3;
inline bool GuildPlantTaskDataProto::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildPlantTaskDataProto::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildPlantTaskDataProto::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildPlantTaskDataProto::clear_task_id() {
  task_id_ = 0;
  clear_has_task_id();
}
inline ::google::protobuf::int32 GuildPlantTaskDataProto::task_id() const {
  return task_id_;
}
inline void GuildPlantTaskDataProto::set_task_id(::google::protobuf::int32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional .app.message.TaskDataProto base_task = 4;
inline bool GuildPlantTaskDataProto::has_base_task() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildPlantTaskDataProto::set_has_base_task() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildPlantTaskDataProto::clear_has_base_task() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuildPlantTaskDataProto::clear_base_task() {
  if (base_task_ != NULL) base_task_->::app::message::TaskDataProto::Clear();
  clear_has_base_task();
}
inline const ::app::message::TaskDataProto& GuildPlantTaskDataProto::base_task() const {
  return base_task_ != NULL ? *base_task_ : *default_instance_->base_task_;
}
inline ::app::message::TaskDataProto* GuildPlantTaskDataProto::mutable_base_task() {
  set_has_base_task();
  if (base_task_ == NULL) base_task_ = new ::app::message::TaskDataProto;
  return base_task_;
}
inline ::app::message::TaskDataProto* GuildPlantTaskDataProto::release_base_task() {
  clear_has_base_task();
  ::app::message::TaskDataProto* temp = base_task_;
  base_task_ = NULL;
  return temp;
}
inline void GuildPlantTaskDataProto::set_allocated_base_task(::app::message::TaskDataProto* base_task) {
  delete base_task_;
  base_task_ = base_task;
  if (base_task) {
    set_has_base_task();
  } else {
    clear_has_base_task();
  }
}

// optional int32 ripe_degree_prize = 5;
inline bool GuildPlantTaskDataProto::has_ripe_degree_prize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildPlantTaskDataProto::set_has_ripe_degree_prize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildPlantTaskDataProto::clear_has_ripe_degree_prize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildPlantTaskDataProto::clear_ripe_degree_prize() {
  ripe_degree_prize_ = 0;
  clear_has_ripe_degree_prize();
}
inline ::google::protobuf::int32 GuildPlantTaskDataProto::ripe_degree_prize() const {
  return ripe_degree_prize_;
}
inline void GuildPlantTaskDataProto::set_ripe_degree_prize(::google::protobuf::int32 value) {
  set_has_ripe_degree_prize();
  ripe_degree_prize_ = value;
}

// repeated int32 phase = 6;
inline int GuildPlantTaskDataProto::phase_size() const {
  return phase_.size();
}
inline void GuildPlantTaskDataProto::clear_phase() {
  phase_.Clear();
}
inline ::google::protobuf::int32 GuildPlantTaskDataProto::phase(int index) const {
  return phase_.Get(index);
}
inline void GuildPlantTaskDataProto::set_phase(int index, ::google::protobuf::int32 value) {
  phase_.Set(index, value);
}
inline void GuildPlantTaskDataProto::add_phase(::google::protobuf::int32 value) {
  phase_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GuildPlantTaskDataProto::phase() const {
  return phase_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GuildPlantTaskDataProto::mutable_phase() {
  return &phase_;
}

// repeated int32 times_limit = 7;
inline int GuildPlantTaskDataProto::times_limit_size() const {
  return times_limit_.size();
}
inline void GuildPlantTaskDataProto::clear_times_limit() {
  times_limit_.Clear();
}
inline ::google::protobuf::int32 GuildPlantTaskDataProto::times_limit(int index) const {
  return times_limit_.Get(index);
}
inline void GuildPlantTaskDataProto::set_times_limit(int index, ::google::protobuf::int32 value) {
  times_limit_.Set(index, value);
}
inline void GuildPlantTaskDataProto::add_times_limit(::google::protobuf::int32 value) {
  times_limit_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GuildPlantTaskDataProto::times_limit() const {
  return times_limit_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GuildPlantTaskDataProto::mutable_times_limit() {
  return &times_limit_;
}

// -------------------------------------------------------------------

// TaskTargetProto

// optional int32 type = 1;
inline bool TaskTargetProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskTargetProto::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskTargetProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskTargetProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TaskTargetProto::type() const {
  return type_;
}
inline void TaskTargetProto::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 npc_id = 2;
inline bool TaskTargetProto::has_npc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskTargetProto::set_has_npc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskTargetProto::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskTargetProto::clear_npc_id() {
  npc_id_ = 0;
  clear_has_npc_id();
}
inline ::google::protobuf::int32 TaskTargetProto::npc_id() const {
  return npc_id_;
}
inline void TaskTargetProto::set_npc_id(::google::protobuf::int32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// optional bytes npc_dialog = 3;
inline bool TaskTargetProto::has_npc_dialog() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskTargetProto::set_has_npc_dialog() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskTargetProto::clear_has_npc_dialog() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskTargetProto::clear_npc_dialog() {
  if (npc_dialog_ != &::google::protobuf::internal::kEmptyString) {
    npc_dialog_->clear();
  }
  clear_has_npc_dialog();
}
inline const ::std::string& TaskTargetProto::npc_dialog() const {
  return *npc_dialog_;
}
inline void TaskTargetProto::set_npc_dialog(const ::std::string& value) {
  set_has_npc_dialog();
  if (npc_dialog_ == &::google::protobuf::internal::kEmptyString) {
    npc_dialog_ = new ::std::string;
  }
  npc_dialog_->assign(value);
}
inline void TaskTargetProto::set_npc_dialog(const char* value) {
  set_has_npc_dialog();
  if (npc_dialog_ == &::google::protobuf::internal::kEmptyString) {
    npc_dialog_ = new ::std::string;
  }
  npc_dialog_->assign(value);
}
inline void TaskTargetProto::set_npc_dialog(const void* value, size_t size) {
  set_has_npc_dialog();
  if (npc_dialog_ == &::google::protobuf::internal::kEmptyString) {
    npc_dialog_ = new ::std::string;
  }
  npc_dialog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskTargetProto::mutable_npc_dialog() {
  set_has_npc_dialog();
  if (npc_dialog_ == &::google::protobuf::internal::kEmptyString) {
    npc_dialog_ = new ::std::string;
  }
  return npc_dialog_;
}
inline ::std::string* TaskTargetProto::release_npc_dialog() {
  clear_has_npc_dialog();
  if (npc_dialog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = npc_dialog_;
    npc_dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskTargetProto::set_allocated_npc_dialog(::std::string* npc_dialog) {
  if (npc_dialog_ != &::google::protobuf::internal::kEmptyString) {
    delete npc_dialog_;
  }
  if (npc_dialog) {
    set_has_npc_dialog();
    npc_dialog_ = npc_dialog;
  } else {
    clear_has_npc_dialog();
    npc_dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 kill_monster_id = 11;
inline bool TaskTargetProto::has_kill_monster_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskTargetProto::set_has_kill_monster_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskTargetProto::clear_has_kill_monster_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskTargetProto::clear_kill_monster_id() {
  kill_monster_id_ = 0;
  clear_has_kill_monster_id();
}
inline ::google::protobuf::int32 TaskTargetProto::kill_monster_id() const {
  return kill_monster_id_;
}
inline void TaskTargetProto::set_kill_monster_id(::google::protobuf::int32 value) {
  set_has_kill_monster_id();
  kill_monster_id_ = value;
}

// optional int32 kill_monster_count = 12;
inline bool TaskTargetProto::has_kill_monster_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskTargetProto::set_has_kill_monster_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskTargetProto::clear_has_kill_monster_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskTargetProto::clear_kill_monster_count() {
  kill_monster_count_ = 0;
  clear_has_kill_monster_count();
}
inline ::google::protobuf::int32 TaskTargetProto::kill_monster_count() const {
  return kill_monster_count_;
}
inline void TaskTargetProto::set_kill_monster_count(::google::protobuf::int32 value) {
  set_has_kill_monster_count();
  kill_monster_count_ = value;
}

// optional int32 drop_goods_monster_id = 21;
inline bool TaskTargetProto::has_drop_goods_monster_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskTargetProto::set_has_drop_goods_monster_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskTargetProto::clear_has_drop_goods_monster_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskTargetProto::clear_drop_goods_monster_id() {
  drop_goods_monster_id_ = 0;
  clear_has_drop_goods_monster_id();
}
inline ::google::protobuf::int32 TaskTargetProto::drop_goods_monster_id() const {
  return drop_goods_monster_id_;
}
inline void TaskTargetProto::set_drop_goods_monster_id(::google::protobuf::int32 value) {
  set_has_drop_goods_monster_id();
  drop_goods_monster_id_ = value;
}

// optional int32 drop_goods_count = 22;
inline bool TaskTargetProto::has_drop_goods_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskTargetProto::set_has_drop_goods_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskTargetProto::clear_has_drop_goods_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskTargetProto::clear_drop_goods_count() {
  drop_goods_count_ = 0;
  clear_has_drop_goods_count();
}
inline ::google::protobuf::int32 TaskTargetProto::drop_goods_count() const {
  return drop_goods_count_;
}
inline void TaskTargetProto::set_drop_goods_count(::google::protobuf::int32 value) {
  set_has_drop_goods_count();
  drop_goods_count_ = value;
}

// optional bytes drop_goods_data = 23 [deprecated = true];
inline bool TaskTargetProto::has_drop_goods_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskTargetProto::set_has_drop_goods_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskTargetProto::clear_has_drop_goods_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskTargetProto::clear_drop_goods_data() {
  if (drop_goods_data_ != &::google::protobuf::internal::kEmptyString) {
    drop_goods_data_->clear();
  }
  clear_has_drop_goods_data();
}
inline const ::std::string& TaskTargetProto::drop_goods_data() const {
  return *drop_goods_data_;
}
inline void TaskTargetProto::set_drop_goods_data(const ::std::string& value) {
  set_has_drop_goods_data();
  if (drop_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_data_ = new ::std::string;
  }
  drop_goods_data_->assign(value);
}
inline void TaskTargetProto::set_drop_goods_data(const char* value) {
  set_has_drop_goods_data();
  if (drop_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_data_ = new ::std::string;
  }
  drop_goods_data_->assign(value);
}
inline void TaskTargetProto::set_drop_goods_data(const void* value, size_t size) {
  set_has_drop_goods_data();
  if (drop_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_data_ = new ::std::string;
  }
  drop_goods_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskTargetProto::mutable_drop_goods_data() {
  set_has_drop_goods_data();
  if (drop_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_data_ = new ::std::string;
  }
  return drop_goods_data_;
}
inline ::std::string* TaskTargetProto::release_drop_goods_data() {
  clear_has_drop_goods_data();
  if (drop_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = drop_goods_data_;
    drop_goods_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskTargetProto::set_allocated_drop_goods_data(::std::string* drop_goods_data) {
  if (drop_goods_data_ != &::google::protobuf::internal::kEmptyString) {
    delete drop_goods_data_;
  }
  if (drop_goods_data) {
    set_has_drop_goods_data();
    drop_goods_data_ = drop_goods_data;
  } else {
    clear_has_drop_goods_data();
    drop_goods_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes drop_goods_name = 24;
inline bool TaskTargetProto::has_drop_goods_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskTargetProto::set_has_drop_goods_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskTargetProto::clear_has_drop_goods_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskTargetProto::clear_drop_goods_name() {
  if (drop_goods_name_ != &::google::protobuf::internal::kEmptyString) {
    drop_goods_name_->clear();
  }
  clear_has_drop_goods_name();
}
inline const ::std::string& TaskTargetProto::drop_goods_name() const {
  return *drop_goods_name_;
}
inline void TaskTargetProto::set_drop_goods_name(const ::std::string& value) {
  set_has_drop_goods_name();
  if (drop_goods_name_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_name_ = new ::std::string;
  }
  drop_goods_name_->assign(value);
}
inline void TaskTargetProto::set_drop_goods_name(const char* value) {
  set_has_drop_goods_name();
  if (drop_goods_name_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_name_ = new ::std::string;
  }
  drop_goods_name_->assign(value);
}
inline void TaskTargetProto::set_drop_goods_name(const void* value, size_t size) {
  set_has_drop_goods_name();
  if (drop_goods_name_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_name_ = new ::std::string;
  }
  drop_goods_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskTargetProto::mutable_drop_goods_name() {
  set_has_drop_goods_name();
  if (drop_goods_name_ == &::google::protobuf::internal::kEmptyString) {
    drop_goods_name_ = new ::std::string;
  }
  return drop_goods_name_;
}
inline ::std::string* TaskTargetProto::release_drop_goods_name() {
  clear_has_drop_goods_name();
  if (drop_goods_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = drop_goods_name_;
    drop_goods_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskTargetProto::set_allocated_drop_goods_name(::std::string* drop_goods_name) {
  if (drop_goods_name_ != &::google::protobuf::internal::kEmptyString) {
    delete drop_goods_name_;
  }
  if (drop_goods_name) {
    set_has_drop_goods_name();
    drop_goods_name_ = drop_goods_name;
  } else {
    clear_has_drop_goods_name();
    drop_goods_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 collect_goods_type = 31;
inline bool TaskTargetProto::has_collect_goods_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskTargetProto::set_has_collect_goods_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskTargetProto::clear_has_collect_goods_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskTargetProto::clear_collect_goods_type() {
  collect_goods_type_ = 0;
  clear_has_collect_goods_type();
}
inline ::google::protobuf::int32 TaskTargetProto::collect_goods_type() const {
  return collect_goods_type_;
}
inline void TaskTargetProto::set_collect_goods_type(::google::protobuf::int32 value) {
  set_has_collect_goods_type();
  collect_goods_type_ = value;
}

// optional int32 collect_goods_count = 32;
inline bool TaskTargetProto::has_collect_goods_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskTargetProto::set_has_collect_goods_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskTargetProto::clear_has_collect_goods_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskTargetProto::clear_collect_goods_count() {
  collect_goods_count_ = 0;
  clear_has_collect_goods_count();
}
inline ::google::protobuf::int32 TaskTargetProto::collect_goods_count() const {
  return collect_goods_count_;
}
inline void TaskTargetProto::set_collect_goods_count(::google::protobuf::int32 value) {
  set_has_collect_goods_count();
  collect_goods_count_ = value;
}

// optional bytes collect_goods_data = 33 [deprecated = true];
inline bool TaskTargetProto::has_collect_goods_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskTargetProto::set_has_collect_goods_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskTargetProto::clear_has_collect_goods_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskTargetProto::clear_collect_goods_data() {
  if (collect_goods_data_ != &::google::protobuf::internal::kEmptyString) {
    collect_goods_data_->clear();
  }
  clear_has_collect_goods_data();
}
inline const ::std::string& TaskTargetProto::collect_goods_data() const {
  return *collect_goods_data_;
}
inline void TaskTargetProto::set_collect_goods_data(const ::std::string& value) {
  set_has_collect_goods_data();
  if (collect_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    collect_goods_data_ = new ::std::string;
  }
  collect_goods_data_->assign(value);
}
inline void TaskTargetProto::set_collect_goods_data(const char* value) {
  set_has_collect_goods_data();
  if (collect_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    collect_goods_data_ = new ::std::string;
  }
  collect_goods_data_->assign(value);
}
inline void TaskTargetProto::set_collect_goods_data(const void* value, size_t size) {
  set_has_collect_goods_data();
  if (collect_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    collect_goods_data_ = new ::std::string;
  }
  collect_goods_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskTargetProto::mutable_collect_goods_data() {
  set_has_collect_goods_data();
  if (collect_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    collect_goods_data_ = new ::std::string;
  }
  return collect_goods_data_;
}
inline ::std::string* TaskTargetProto::release_collect_goods_data() {
  clear_has_collect_goods_data();
  if (collect_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = collect_goods_data_;
    collect_goods_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskTargetProto::set_allocated_collect_goods_data(::std::string* collect_goods_data) {
  if (collect_goods_data_ != &::google::protobuf::internal::kEmptyString) {
    delete collect_goods_data_;
  }
  if (collect_goods_data) {
    set_has_collect_goods_data();
    collect_goods_data_ = collect_goods_data;
  } else {
    clear_has_collect_goods_data();
    collect_goods_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 upgrade_level = 41;
inline bool TaskTargetProto::has_upgrade_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TaskTargetProto::set_has_upgrade_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TaskTargetProto::clear_has_upgrade_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TaskTargetProto::clear_upgrade_level() {
  upgrade_level_ = 0;
  clear_has_upgrade_level();
}
inline ::google::protobuf::int32 TaskTargetProto::upgrade_level() const {
  return upgrade_level_;
}
inline void TaskTargetProto::set_upgrade_level(::google::protobuf::int32 value) {
  set_has_upgrade_level();
  upgrade_level_ = value;
}

// optional int32 upgrade_recommend_monster = 42;
inline bool TaskTargetProto::has_upgrade_recommend_monster() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TaskTargetProto::set_has_upgrade_recommend_monster() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TaskTargetProto::clear_has_upgrade_recommend_monster() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TaskTargetProto::clear_upgrade_recommend_monster() {
  upgrade_recommend_monster_ = 0;
  clear_has_upgrade_recommend_monster();
}
inline ::google::protobuf::int32 TaskTargetProto::upgrade_recommend_monster() const {
  return upgrade_recommend_monster_;
}
inline void TaskTargetProto::set_upgrade_recommend_monster(::google::protobuf::int32 value) {
  set_has_upgrade_recommend_monster();
  upgrade_recommend_monster_ = value;
}

// optional bytes depot_goods_data = 51;
inline bool TaskTargetProto::has_depot_goods_data() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TaskTargetProto::set_has_depot_goods_data() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TaskTargetProto::clear_has_depot_goods_data() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TaskTargetProto::clear_depot_goods_data() {
  if (depot_goods_data_ != &::google::protobuf::internal::kEmptyString) {
    depot_goods_data_->clear();
  }
  clear_has_depot_goods_data();
}
inline const ::std::string& TaskTargetProto::depot_goods_data() const {
  return *depot_goods_data_;
}
inline void TaskTargetProto::set_depot_goods_data(const ::std::string& value) {
  set_has_depot_goods_data();
  if (depot_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    depot_goods_data_ = new ::std::string;
  }
  depot_goods_data_->assign(value);
}
inline void TaskTargetProto::set_depot_goods_data(const char* value) {
  set_has_depot_goods_data();
  if (depot_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    depot_goods_data_ = new ::std::string;
  }
  depot_goods_data_->assign(value);
}
inline void TaskTargetProto::set_depot_goods_data(const void* value, size_t size) {
  set_has_depot_goods_data();
  if (depot_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    depot_goods_data_ = new ::std::string;
  }
  depot_goods_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskTargetProto::mutable_depot_goods_data() {
  set_has_depot_goods_data();
  if (depot_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    depot_goods_data_ = new ::std::string;
  }
  return depot_goods_data_;
}
inline ::std::string* TaskTargetProto::release_depot_goods_data() {
  clear_has_depot_goods_data();
  if (depot_goods_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = depot_goods_data_;
    depot_goods_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskTargetProto::set_allocated_depot_goods_data(::std::string* depot_goods_data) {
  if (depot_goods_data_ != &::google::protobuf::internal::kEmptyString) {
    delete depot_goods_data_;
  }
  if (depot_goods_data) {
    set_has_depot_goods_data();
    depot_goods_data_ = depot_goods_data;
  } else {
    clear_has_depot_goods_data();
    depot_goods_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 depot_goods_count = 52;
inline bool TaskTargetProto::has_depot_goods_count() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TaskTargetProto::set_has_depot_goods_count() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TaskTargetProto::clear_has_depot_goods_count() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TaskTargetProto::clear_depot_goods_count() {
  depot_goods_count_ = 0;
  clear_has_depot_goods_count();
}
inline ::google::protobuf::int32 TaskTargetProto::depot_goods_count() const {
  return depot_goods_count_;
}
inline void TaskTargetProto::set_depot_goods_count(::google::protobuf::int32 value) {
  set_has_depot_goods_count();
  depot_goods_count_ = value;
}

// optional int32 dungeon = 61;
inline bool TaskTargetProto::has_dungeon() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TaskTargetProto::set_has_dungeon() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TaskTargetProto::clear_has_dungeon() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TaskTargetProto::clear_dungeon() {
  dungeon_ = 0;
  clear_has_dungeon();
}
inline ::google::protobuf::int32 TaskTargetProto::dungeon() const {
  return dungeon_;
}
inline void TaskTargetProto::set_dungeon(::google::protobuf::int32 value) {
  set_has_dungeon();
  dungeon_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message
}  // namespace app

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::message::TaskRelatedFunction>() {
  return ::app::message::TaskRelatedFunction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::message::CommonTaskType>() {
  return ::app::message::CommonTaskType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::message::ClientFunction>() {
  return ::app::message::ClientFunction_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
